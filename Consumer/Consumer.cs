/*
 * Here we create several consumers. And you can see that messages are going to consumers in a round-robbin manner.
 * Namely, every consumer gets message one after another.
 * Consumer 1 Consumer 2
 * 
 * message 1  Message 2
 * message 3  Message 4
 *
 * etc...
 *
 * You can provide waiting function to consumers and see that each one will get next message from the queue
 */
using System.Text;
using QueueSettings;
using QueueSettings.Exchanges;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;
namespace Consumer;

public class Consumer
{
    public static async Task Run(int number, TaskCompletionSource taskCompletionSource)
    {
            var connectionFactory = new ConnectionFactory()
            {
                HostName = "localhost"
            };
            
            var indent = new string(' ', number * Constants.IndentLength);

            using (var connection = connectionFactory.CreateConnection())
            {
                using (var channel = connection.CreateModel())
                {
                    Console.WriteLine(indent + $"Started Consumer {number + 1}");
                    
                    // here we are gonna declare default queue, and use name generated by rabbit for it
                    var queue = channel.QueueDeclare();
                    var fanOutExchangeConfig = new FanOutExchangeConfig();
                    
                    channel.QueueBind(
                        queue: queue.QueueName,
                        exchange: fanOutExchangeConfig.Name, 
                        routingKey: string.Empty);
                    
                    var consumer = new EventingBasicConsumer(channel);

                    consumer.Received += (sender, eventArgs) =>
                    {
                        var message = Encoding.UTF8.GetString(eventArgs.Body.ToArray());
                        Console.WriteLine(indent + $"Recieved: \"{message}\" by consumer {number + 1}");
                    };

                    channel.BasicConsume(queue.QueueName, true, consumer);
                    
                    await taskCompletionSource.Task;
                }
            }
    }
}